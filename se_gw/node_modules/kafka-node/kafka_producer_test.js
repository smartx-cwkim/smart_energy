#!/usr/bin/env node

"use strict"

var MESSAGE_RATE = 500;
var RANDOM_DATA = 500;
var ZOOKEEPER_HOST=process.env.ZOOKEEPER_HOST || '192.168.99.100'
const TOPIC = 'ProducerConnectivityTest'

var kafka  = require('./kafka')

// var AsyncKafkaProducer = require('./AsyncKafkaProducer')


var debug = require('debug')('kafka-node:Test');

var KeyedMessage = kafka.KeyedMessage


var client, producer

createClientProducer()

function createClient() {
	var client = new kafka.Client(ZOOKEEPER_HOST+ ':2181', 'kafka-testing')
	return client
}


function createProducer(client) {
	// var producer = new kafka.HighLevelProducer(client)
	var producer = new kafka.Producer(client)
	return producer
}

function createClientProducer() {
	debug('creating new client & producer')
	client = createClient()
	producer = createProducer(client)

	client.on('connect', function(){
		debug('Client connect')
	})

	client.on('reconnect', function(){
		debug('Client reconnect');
	})

	producer.on('ready', onProducerReady)
	producer.on('error', onProducerError)
	producer.on('close', function(){
		debug('Producer Close')
	})
}

function onProducerReady(){
		debug('producer ready!')
		startLoop()
	}

function onProducerError(error) {
		debug('Producer Error', error);
		if (error == null) process.exit(9)
		if (error.name == 'NO_NODE') {
			onError();
			debug('retrying in 5 seconds.')
			setTimeout(createClientProducer, 5000);
		}
}

var messageNumber = 0

function onError() {

	debug('cleaning up client producer')

	if (client && producer) {
		debug('calling close on producer')
		producer.close()
		producer.removeListener('ready', onProducerReady)
		producer.removeListener('error', onProducerError)
	}

	producer = null
	client = null
}

const keys = ['mykey', 'herkey', 'theirkey']

function startLoop() {
	if (client && producer) {
		var currentNumber = messageNumber
		debug('Sending message #'+ messageNumber)
		var hrstart = process.hrtime();
		sendCb.__messageNumber = currentNumber
		producer.send([{
		   topic: TOPIC,
		   // messages: (new Array(RANDOM_DATA).join(Math.random().toString(36))) + ' Received message # ' + messageNumber++
		   partition: 1,
		   attributes: 0,
		   messages: new KeyedMessage( keys[Math.floor(Math.random() * 3) + 0], (new Array(RANDOM_DATA).join(Math.random().toString(36))) + ' Received message # ' + messageNumber++) // multi messages should be a array, single message can be just a string or a KeyedMessage instance
		}], sendCb)
		// debug('sent. Waiting 1 seconds....')
		setTimeout(startLoop, MESSAGE_RATE);
	} else {
		debug('client and producer is null')
	}

	function sendCb(error){
		var hrend = process.hrtime(hrstart);
		debug('Callback called for #%d, took: %ds %dms', currentNumber, hrend[0], hrend[1]/1e6);
		hrstart = null
		if (error) {
			debug('Send Callback Error #'+ currentNumber, error)
			// console.trace();
		}
		currentNumber = null
	}
}

process.on('SIGINT', function() {
	console.log("Caught interrupt signal");
	producer.close(function(){
		process.exit();
	})
});

process.on('uncaughtException', function(err) {
    // handle the error safely
    console.error('uncaughtException:', err)
    console.log(err.stack)
    // process.exit(9)
})